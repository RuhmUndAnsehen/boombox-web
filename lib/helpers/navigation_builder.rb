# frozen_string_literal: true

module Helpers
  ##
  # A HTML builder class that facilitates the generation of +nav+ tags and their
  # contents. It provides helpers (#bar, #menu) for a few default navigation
  # styles, as well a flexible navigation #item interface, and #link_to
  # helpers that add the +.current-page+ CSS class to all parent item tags if
  # they link to the current page.
  class NavigationBuilder
    attr_reader :view_context

    def initialize(view_context, parent = nil)
      @view_context = view_context
      @parent = parent
    end

    def capture(*, &) = view_context.capture(self, *, &)

    def current_page?(*args, **opts)
      return @current_page unless args.present? || opts.present?

      view_context.current_page?(*args, **opts)
    end

    ##
    # Called by #link_to to indicate that the link points to the current page.
    #
    # Cascades up the HTML element hierarchy.
    def current_page!
      @parent&.current_page!
      @current_page = true
    end

    def current_page_options(options = {})
      add_class('current-page', to: options) if current_page?
      options
    end

    ##
    # Calls #nav with the +.nav-bar+ CSS class set.
    def bar(**, &) = nav_('bar', **, &)

    ##
    # Generates a navigation item and yields a NavigationBuilder if block given.
    # If a #link_to inside this nav-item points to the current site, the CSS
    # class +.current-page+ will be added to the item (this includes links
    # inside a sub #menu).
    #
    # Rendering behavior is as follows:
    # * If no arguments or a single Hash are given, all content is assumed to be
    #   generated by the block. The Hash, if given, is assumed to be HTML
    #   options for the item tag.
    # * If the first argument is a String, then behavior depends on if a block
    #   is given. If it is, the String is wrapped in a +span+ tag, and the
    #   captured block appended to it (similarly to the previous case).
    #   If no block is given, the parameters are passed verbatim to #link_to
    #   which becomes the item tag content in this case.
    def item(*args, &block)
      case args
      in [] | [Hash]
        render_item(''.html_safe, *args, &block)
      in [String, *]
        return render_item(*render_item_link(*args), &block) unless block_given?

        text, options = *args
        render_item(content_tag(:span, text), options, &block)
      end
    end

    ##
    # Like ActionView::UrlHelper#link_to, but invokes #current_page! if the
    # href points to the current page.
    #
    # Use regular +link_to+ if you want to avoid this behavior.
    def link_to(*args, &block)
      options = args[block_given? ? 0 : 1] || {}
      current_page! if current_page?(options)

      view_context.link_to(*args, &block)
    end

    ##
    # Like ActionView::UrlHelper#link_to_unless_current, but invokes
    # #current_page! if the href points to the current page. Also wraps the
    # fallback text in a +span+.
    def link_to_unless_current(name, options = {}, html_options = {}, &block)
      if current_page?(options)
        current_page!
        return content_tag(:span, name, html_options) unless block_given?

        view_context.capture(name, options, html_options, &block)
      else
        link_to(name, options, html_options)
      end
    end

    ##
    # Calls #nav with the +.nav-menu+ CSS class set.
    def menu(**, &) = nav_('menu', **, &)

    ##
    # Delegate missing methods to #view_context.
    def method_missing(name, ...)
      return super unless view_context.respond_to?(name)

      view_context.__send__(name, ...)
    end

    ##
    # Generates a navigation item container tag and yields a NavigationBuilder.
    def nav(**opts, &block) = content_tag(:ul, capture(&block), opts)

    def nav_(type, **opts, &block)
      nav(**add_class("nav-#{type}", to: opts), &block)
    end

    ##
    # Generates a +nav+ tag. Prefer NavigationHelper#nav_tag over calling this
    # method directly.
    def nav_tag(options, &block) = content_tag(:nav, capture(&block), options)

    def new = self.class.new(view_context, self)

    private

    def add_class(cls, to:)
      cls = cls[:class] if cls.is_a?(Hash)
      return { class: cls } if to.nil?
      return to if cls.blank?

      to_cls = to[:class]
      to[:class] = [to_cls, cls].compact.join(' ')
      to
    end

    def render_item(content, options = {}, &block)
      if block_given?
        spawn = new
        content += spawn.capture(&block)
        options = spawn.current_page_options(options)
      end
      content_tag(:li, content, add_class('nav-item', to: options))
    end

    def render_item_link(*)
      spawn = new
      [spawn.link_to(*), spawn.current_page_options]
    end

    def respond_to_missing?(...) = view_context.respond_to?(...)
  end
end
